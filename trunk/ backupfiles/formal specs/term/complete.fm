---Defines commonly used data types
fmod DataTypes is
	protecting INT .
	protecting NAT .
	protecting LIST{Int} .
	protecting STRING .
	
	sorts Address Value StackElement Input Output ProgramCounter Label .
	subsort Nat < Address .								--- Addresses = natural numbers
	subsort Int < Value .								--- Values = Ints
	subsort Address < StackElement .					--- Either addresses or values can go on the stack
	subsort Value < StackElement .
	subsort List{Int} < Input .							--- Input and output = lists of ints
	subsort List{Int} < Output .
	subsort Nat < ProgramCounter .						--- Program counter = natural number
	subsort String < Label .							--- Labels = strings
	
	op NullPointerError(_) : Address -> Value [ctor] . 	--- Error thrown when accessing an address that wasn't assigned to
	op StackEmptyError : -> StackElement [ctor] . 		--- Error thrown when trying to pop from an empty stack
endfm

---Stack used by the stack computer
fmod Stack is 
	protecting DataTypes .
	
	sort Stack . 
	
  	op empty : -> Stack [ctor] .
  	op Push(_,_) : Stack StackElement -> Stack [ctor] .  
  	op Pop(_) : Stack -> Stack [ctor] .
  	op Top(_) : Stack -> StackElement .
  	op IsEmpty(_) : Stack -> Bool .
  	op StackEmptyError : -> Stack .						--- Error thrown when trying to Pop or Top an empty stack
  	
  	var stack : Stack .
    var element : StackElement .
  
  	eq Pop(Push(stack,element)) = stack .
  	eq Top(Push(stack,element)) = element .
  	eq IsEmpty(empty) = true .
  	eq IsEmpty(Push(stack,element)) = false .
  	eq Top(empty) = StackEmptyError .
  	eq Pop(empty) = StackEmptyError .

endfm

--- Memory of the stack computer
fmod Memory is 
	protecting DataTypes .
	
	sorts Memory .
	
	op init : -> Memory [ctor] .
	op _[_,_] : Memory Address Value -> Memory [ctor] . 	--- store
	op _[_] : Memory Address -> Value [ctor] . 				---load
	
	vars address address2 : Address .
	var value value2 : Value .
	var memory : Memory .
	 	
	 eq memory[address,value][address] = value .
	 ceq memory[address,value][address2] = memory[address2] if address =/= address2 .
	 eq init[address] = NullPointerError(address) . 
	 eq memory[address, value][address,value2] = memory[address, value2] .	 
endfm

--- Instruction set of the stack computer
fmod Instruction is	
	protecting DataTypes .

	sort Instruction .
	
	op TA _ : Address -> Instruction [ctor] . 		--- pushes an address to the stack
	op TC _ : Value -> Instruction [ctor] . 		--- pushes a value to the stack
	op DR : -> Instruction [ctor] . 				--- dereferences the top of the stack, puts the result value on the stack
	op ST : -> Instruction [ctor] .					--- stores top of the stack to the address that is below the top
	op AD : -> Instruction [ctor] .					--- adds two values on the top of the stack, pushes the result on the stack
	op RD : -> Instruction [ctor] .					--- reads a value from the input and pushes it on the stack
	op WR : -> Instruction [ctor] .					--- takes a value from the stack and writes it to the output
	op LAB _ : Label -> Instruction [ctor] . 		--- declares a label
	op JU _ : Label -> Instruction [ctor] . 		--- jumps to given label
	op JNZ _ : Label -> Instruction [ctor] .		--- jumps to given label if there is non zero on top of the stack

	op InvalidProgramCounterError : -> Instruction [ctor].	--- program counter doesn't point to any instruction
endfm

--- Code used by the stack computer
fmod Code is 
	protecting Instruction .
	protecting DataTypes .
	sort Code .
	subsort Instruction < Code .
	
	op _;_ : Instruction Code -> Code [ctor] .		--- Basic code concatenation
	op GetInstruction(_,_) : Code ProgramCounter -> Instruction .	--- Returns instruction on given counter
	op FindLabel(_,_) : Code Label -> ProgramCounter .	--- Returns counter of the LAB instruction defining given label
	
	var instruction : Instruction .
	var code : Code .
	var counter : ProgramCounter .
	vars lab : Label .
	
	eq GetInstruction(instruction,1) = instruction .
	ceq GetInstruction(instruction,counter) = InvalidProgramCounterError if counter > 1 .
	eq GetInstruction(instruction ; code,1) = instruction .
	ceq GetInstruction(instruction ; code,counter) = GetInstruction(code,sd(counter,1)) if counter > 1 .
	eq FindLabel(LAB lab,lab) = 1 .
	eq FindLabel(LAB lab ; code,lab) = 1 .	
	ceq FindLabel(instruction ; code,lab) = 1 + FindLabel(code,lab) if instruction =/= LAB lab .
endfm

--- Defines state of the stack computer, state=(stack,input,output,memory,code,program counter)
fmod ComputerState is
	protecting DataTypes .
	protecting Code .
	protecting Memory .
	protecting Stack .
	
	sort ComputerState .
	
	op state(_,_,_,_,_,_) : Stack Input Output Memory Code ProgramCounter -> ComputerState [ctor] .
	--- Getters
	op GetStack(_) : ComputerState -> Stack .
	op GetInput(_) : ComputerState -> Input .
	op GetOutput(_) : ComputerState -> Output .
	op GetMemory(_) : ComputerState -> Memory .
	op GetCode(_) : ComputerState -> Code .
	op GetProgramCounter(_) : ComputerState -> ProgramCounter .
	op GetCurrentInstruction(_) : ComputerState -> Instruction .
	op IncrementCounter(_) : ComputerState -> ComputerState . ---Increases the PC value by 1
	
	var stack : Stack .
	var input : Input .
	var output : Output .
	var memory : Memory .
	var code : Code .
	var counter : ProgramCounter .
	
	eq GetStack(state(stack, input, output, memory, code, counter)) = stack .
	eq GetInput(state(stack, input, output, memory, code, counter)) = input .
	eq GetOutput(state(stack, input, output, memory, code, counter)) = output .
	eq GetMemory(state(stack, input, output, memory, code, counter)) = memory .
	eq GetCode(state(stack, input, output, memory, code, counter)) = code .
	eq GetProgramCounter(state(stack, input, output, memory, code, counter)) = counter .
	eq GetCurrentInstruction(state(stack, input, output, memory, code, counter)) = GetInstruction(code,counter) .	
	
endfm

--- Defines the whole computer
fmod Computer is
	protecting ComputerState .
	--- Performs one step of the computer = executes instruction on current program counter
	op Step(_) : ComputerState -> ComputerState .
	--- Performs all the steps of the computer's code
	op AllSteps(_) : ComputerState -> ComputerState .
	--- Main method of the specification - runs given code with given input on the computer
	op RunProgram(_,_) : Code Input -> Output .
	--- Creates the initial computer state from given code and input
	op LoadCode(_,_) : Code Input -> ComputerState .
	--- Executes given instruction
	op DoInstruction(_,_) : ComputerState Instruction -> ComputerState .	
		
	var st : ComputerState .
	var code : Code .
	var input : Input .
	var address : Address .
	var value : Value .
	var lab : Label .
	
	eq LoadCode(code,input) = state(empty,input, nil, init, code, 1) .  
	ceq AllSteps(st) = AllSteps(Step(st)) if GetCurrentInstruction(st) =/= InvalidProgramCounterError .
	ceq AllSteps(st) = st if GetCurrentInstruction(st) == InvalidProgramCounterError .
	eq RunProgram(code,input) = GetOutput(AllSteps(LoadCode(code,input))) .		
	eq Step(st) = DoInstruction(st,GetCurrentInstruction(st)) .		
	
	--- Just push the argument on the stack, increment counter
	eq DoInstruction(st,TA address) = state(Push(GetStack(st),address),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Just push the argument on the stack, increment counter
	eq DoInstruction(st,TC value) =  state(Push(GetStack(st),value),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Remove the address from stack, push the value on that address, increment counter
	eq DoInstruction(st,DR) = state(Push(Pop(GetStack(st)),GetMemory(st)[Top(GetStack(st))]),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Remove the value and the address from stack, store that value on that address, increment counter
	eq DoInstruction(st,ST) = state(Pop(Pop(GetStack(st))),GetInput(st),GetOutput(st),GetMemory(st)[Top(Pop(GetStack(st))),Top(GetStack(st))],GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Remove the two values from the stack, add them together, push the sum, increment counter
	eq DoInstruction(st,AD) = state(Push(Pop(Pop(GetStack(st))),Top(GetStack(st)) + Top(Pop(GetStack(st)))),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Take one value from the input, push it on the stack, increment counter
	eq DoInstruction(st,RD) = state(Push(GetStack(st),head(GetInput(st))),tail(GetInput(st)),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Remove one value from the stack, put it into the output, increment counter
	eq DoInstruction(st,WR) = state(Pop(GetStack(st)),GetInput(st),append(GetOutput(st),Top(GetStack(st))),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Just increment counter
	eq DoInstruction(st,LAB lab) = state(GetStack(st),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1) .
	
	--- Change the counter so it points on the right LAB instruction
	eq DoInstruction(st,JU lab) = state(GetStack(st),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),FindLabel(GetCode(st),lab)) .
	
	--- If the top of the stack is 0, just increment the counter
	ceq DoInstruction(st,JNZ lab) = state(GetStack(st),GetInput(st),GetOutput(st),GetMemory(st),GetCode(st),GetProgramCounter(st) + 1)  if Top(GetStack(st)) == 0 .
	
	--- If the top of the stack is non-zero, perform the JU instruction with the same argument
	ceq DoInstruction(st,JNZ lab) = DoInstruction(st,JU lab) if Top(GetStack(st)) =/= 0 .
	
endfm


***(
Test case 1 (sum)
reduce in Computer : RunProgram(
TC 0 ;                
TA 1 ;
RD ;
LAB "start" ;
ST ;
RD ; 
AD ; 
TA 1 ;
TA 1 ;
DR ;
TC -1 ;
AD ;
JNZ "start" ;
ST ;
WR ,
12 10 20 30 40 50 60 70 80 90 100 11 -10) . 
)

***(
Test case 2 (arithmetic sequence)
reduce in Computer : RunProgram(
TC 0 ; 
TA 2 ; 
RD ; 
ST ; 
TA 1 ; 
TA 2 ; 
DR ; 
LAB "start" ; 
ST ; 
TA 1 ; 
DR ; 
TA 1 ; 
TA 1 ; 
DR ; 
TC -1 ; 
AD ; 
JNZ "start" ; 
ST ; 
LAB "start2" ; 
WR ; 
JNZ "start2",
30) .
)

***(
Test case 3 (Odd/Even)
reduce in Computer : RunProgram(
RD ; 
TA 1 ; 
TC 1 ; 
ST ; 
LAB "step1" ; 
TC -1 ; 
AD ; 
TA 1 ; 
TC 0 ; 
ST ; 
JNZ "step2" ; 
JU "result" ; 
LAB "step2" ; 
TC -1 ; 
AD ; 
TA 1 ; 
TC 1 ; 
ST ; 
JNZ "step1" ; 
LAB "result" ; 
TA 1 ; 
DR ; 
JNZ "even" ; 
JU "odd" ; 
LAB "even" ; 
TC 1 ; 
WR ; 
JU "end" ; 
LAB "odd" ; 
TC 0 ; 
WR ; 
LAB "end",
43) .
)